---
title: "MRRPROJECT.Rmd"
output: html_document
date: "2025-11-24"
---

## Classification of Cancer outcome using Genetic and Clinical data

# Introduction

This project investigates the effect of genetic and clinical variables on the survival outcome of breast cancer patients. The data contains records of more than 1000 breast cancer patients from several research institutions. Clinical data contains patient-related and tumor-related information. Additionally mRNA gene expression data is available for each patient. The gene expression data has been processed to include only the top 5000 most variable genes on the transformed scale (log2(counts + 1)).

We consider that the main outcome variable of interest is **vital_status**, which is defined in clinical data.

## Data loading

```{r cars}
# Data loading
load("mrr_bio.Rdata")
library('S4Vectors')
```

```{r}
# genetic data
Gdata = data.frame(GeneX)
head(Gdata)
```

```{r}
# clinical data
Cdata = data.frame(clinical_data)

# Identiy the rows to keep
keep_idx <- !is.na(Cdata$vital_status)
# Filtrer Cdata
Cdata <- Cdata[keep_idx, ]
# Filtrer Gdata
Gdata <- Gdata[keep_idx, ]

head(Cdata)
```
```{r}
# The bcr_patient_barcode and primary_site can be dropped 
Cdata$bcr_patient_barcode <- NULL # no relevant informations
# diesease type and primary_site column are constant so we will drop them
Cdata$disease_type <- NULL
Cdata$primary_site <- NULL
Cdata$days_to_birth <- NULL #redondent
Cdata$age_at_index <- NULL
```

## Exploratory data analysis
### GeneX dataset:
```{r}
# dimension 
dim(Gdata)

# data types
paste("Existing data types: ", unique(sapply(Gdata, class)))

# duplicates
#paste("Is there duplicates: " , unique(duplicated(Gdata))

# missing values
paste("Is there NAN: ", anyNA(Gdata))

# summary statistics of first 10 genes
apply(Gdata[,1:10],2, summary)

# visualisation: 
# distribution of the first column
library(ggplot2)
ggplot(Gdata[,1:10], aes(x = CLEC3A)) +geom_histogram()

# heatmap of the first 10 genes
library(pheatmap)
pheatmap(Gdata[, 1:10], scale="row")
```


### clinical_data dataset:
```{r}
# dimension 
dim(Cdata)

# data types
print("Existing data types: ")
unique(sapply(Cdata, class))
```
```{r}
# duplicates
#print("Is there duplicates: ") 
#unique(duplicated(Gdata))

# missing values
print("Is there NAN: ")
sapply(Cdata, function(x) sum(is.na(x)))
```
```{r}
library(naniar)
# Visualisation of NA
vis_miss(Cdata)
```

We have 2% missing values, so we have to either drop them or impute them with relevant values with the right method.

#### Summary statistics and missing values imputation

```{r}
# Before summarizing, we will divide our dataset based on different data type variables
num_cols <- sapply(Cdata, is.numeric) 
num_Cdata = Cdata[, num_cols]

head(num_Cdata)
summary(num_Cdata)
```
```{r}
# All continuous variables can be imputed with the mean
for(col in colnames(num_Cdata)){
  Cdata[[col]][is.na(Cdata[[col]])] <- mean(Cdata[[col]], na.rm = TRUE)
}
# missing values
print("Is there NAN: ")
sapply(Cdata, function(x) sum(is.na(x)))
```

```{r}
# character variables dataframe
chr_cols <- sapply(Cdata, is.character)
chr_Cdata = Cdata[, chr_cols]

head(chr_Cdata)
summary(chr_Cdata)
```

```{r}
# list of the unique values 
for(col in colnames(chr_Cdata)){
  print(unique(chr_Cdata[col]))
}
```
```{r}
Cdata[["laterality"]][is.na(Cdata[["laterality"]])] <- "not reported"
Cdata[["prior_treatment"]][is.na(Cdata[["prior_treatment"]])] <- "not reported"
Cdata[["prior_treatment"]][Cdata[["prior_treatment"]] == "Not Reported"] <- "not reported"
Cdata[["ajcc_pathologic_t"]][is.na(Cdata[["ajcc_pathologic_t"]])] <- "not reported"
Cdata[["morphology"]][Cdata[["morphology"]] == "Not Reported"] <- "not reported"
Cdata[["classification_of_tumor"]][is.na(Cdata[["classification_of_tumor"]])] <- "not reported"
Cdata[["follow_ups_disease_response"]][is.na(Cdata[["follow_ups_disease_response"]])] <- "not reported"
Cdata[["follow_ups_disease_response"]][Cdata[["follow_ups_disease_response"]] == "Unknown"] <- "not reported"
Cdata[["race"]][is.na(Cdata[["race"]])] <- "not reported"
Cdata[["gender"]][is.na(Cdata[["gender"]])] <- "female"
Cdata[["ethnicity"]][is.na(Cdata[["ethnicity"]])] <- "not reported"
Cdata[["ethnicity"]][Cdata[["ethnicity"]] == "Unknown"] <- "not reported"
```


```{r}
# missing values
print("Is there NAN: ")
sapply(Cdata, function(x) sum(is.na(x)))
```
```{r}
# logical variables dataframe
# Binary variables can be imputed by the most common value

# compute the mode

get_mode <- function(x) {
    ux <- unique(x)
    ux[which.max(tabulate(match(x, ux)))]
}

bin_cols <- sapply(Cdata, is.logical)
bin_Cdata = Cdata[, bin_cols]

head(bin_Cdata)
summary(bin_Cdata)
```


```{r}
for(col in colnames(bin_Cdata)){
  Cdata[[col]][is.na(Cdata[[col]])] <- get_mode(bin_Cdata[[col]])
}
# missing values
print("Is there NAN: ")
sapply(Cdata, function(x) sum(is.na(x)))
```

```{r}
# list variables dataframe
list_cols <- sapply(Cdata, is.list)
list_Cdata = Cdata[, list_cols]

head(list_Cdata)
```

```{r}
# list of the unique values 
for(col in colnames(list_Cdata)){
  print(unique(list_Cdata[col]))
}
```
### Non-numerical variables encoding
Now there is no missing values we can procede to the encoding of non-numerical variables. Fortunatly R have a bultin function which is factor. It internally transform the categoriel variables into dummies.

```{r}
# we transfom the list variables into characters in order to be factorized
Cdata$sites_of_involvement <- sapply(Cdata$sites_of_involvement, function(x) paste(unlist(x), collapse = "_"))
Cdata$tissue_or_organ_of_origin <- sapply(Cdata$tissue_or_organ_of_origin, function(x) paste(unlist(x), collapse = "_"))
# Toutes les colonnes
all_cols <- colnames(Cdata)

# numerical columns
num_cols <- colnames(num_Cdata)

# non numerical columns
non_num_cols <- non_num_cols <- setdiff(colnames(Cdata), num_cols)

# Colonnes list
list_cols <- colnames(list_Cdata)

# transforming non numerical columns into factors
for(col in non_num_cols){
  Cdata[[col]] <- as.factor(Cdata[[col]])
}
```

```{r}
head(Cdata)
```

# Model on clinical_data only:

```{r}
library(glmnet)
set.seed(42)
# Split 70% train / 30% test
n <- nrow(Cdata)
Cdata_scaled <- Cdata
Cdata_scaled[, num_cols] <- scale(Cdata_scaled[, num_cols])
train_idx <- sample(1:n, size = 0.7*n)
test_idx <- setdiff(1:n, train_idx)

train <- Cdata_scaled[train_idx, ]
test <- Cdata_scaled[test_idx, ]

# Target
y_train <- train$vital_status
y_test  <- test$vital_status

# Features from model.matrix
X_train <- model.matrix(~ ., data = train[, setdiff(names(train), "vital_status")])[,-1]
X_test  <- model.matrix(~ ., data = test[, setdiff(names(test), "vital_status")])[,-1]

# Lasso with CV on train data
cv <- cv.glmnet(X_train, y_train, family = "binomial", alpha = 1)

# best lambda
lambda_best <- cv$lambda.min

# trainfinal lasso model
lasso <- glmnet(X_train, y_train, family = "binomial", alpha = 1, lambda = lambda_best)
```

```{r}
# Prediction on test dataset
yhat_test = predict(lasso, newx=X_test, type="response")
yhat_class <- ifelse(yhat_test > 0.08, "Dead", "Alive")
table(y_test, yhat_class)
# Taux de précision
mean(yhat_class == y_test)
```


```{r}
library(pROC)
roc_obj <- roc(y_test, yhat_test) 

# Plot ROC curve
plot(roc_obj, col="blue", main="ROC Curve")

# Best threshold according to Youden cryteria
opt <- coords(roc_obj, "best", best.method="youden", ret=c("threshold","sensitivity","specificity"))
print(opt)
```

# Model on GeneX only:
```{r}
# Split 70% train / 30% test
set.seed(42)
Gdata_scaled <- data.frame(vital_status = Cdata$vital_status, scale(Gdata))

n <- nrow(Gdata_scaled)
train_idx <- sample(1:n, size = 0.7*n)
test_idx <- setdiff(1:n, train_idx)

train <- Gdata_scaled[train_idx, ]
test <- Gdata_scaled[test_idx, ]

# Target
y_train <- train$vital_status
y_test  <- test$vital_status

# Features from model.matrix
X_train <- model.matrix(~ ., data = train[, setdiff(names(train), "vital_status")])[,-1]
X_test  <- model.matrix(~ ., data = test[, setdiff(names(test), "vital_status")])[,-1]

# Lasso with CV on train data
cv <- cv.glmnet(X_train, y_train, family = "binomial", alpha = 1)

# best lambda
lambda_best <- cv$lambda.min

# trainfinal lasso model
lasso <- glmnet(X_train, y_train, family = "binomial", alpha = 1, lambda = lambda_best)
```

```{r}
# Prediction on test dataset
yhat_test = predict(lasso, newx=X_test, type="response")
yhat_class <- ifelse(yhat_test > 0.15, "Dead", "Alive")
table(y_test, yhat_class)
# Taux de précision
mean(yhat_class == y_test)
```


```{r}
library(pROC)
roc_obj <- roc(y_test, yhat_test) 

# Plot ROC curve
plot(roc_obj, col="blue", main="ROC Curve")

# Best threshold according to Youden cryteria
opt <- coords(roc_obj, "best", best.method="youden", ret=c("threshold","sensitivity","specificity"))
print(opt)
```

# Screening Model:
```{r}
x <- scale(as.matrix(Gdata))
y <- Cdata$vital_status

cv <- cv.glmnet(x, y, family = "binomial", alpha = 1)

lasso <- glmnet(x, y, family = "binomial", alpha = 1, lambda = cv$lambda.min)

coef_lasso <- coef(lasso)

# Extraire les variables non nulles
sig_vars <- rownames(coef_lasso)[coef_lasso[,1] != 0]
sig_vars <- sig_vars[sig_vars != "(Intercept)"]
```

```{r}
df_final = cbind(Cdata, scale(Gdata[, sig_vars]))
df_final[, num_cols] = scale(df_final[, num_cols])
head(df_final)
```

```{r}
library(glmnet)
set.seed(3)

# Split 70% train / 30% test
n <- nrow(df_final)
train_idx <- sample(1:n, size = 0.7*n)
test_idx <- setdiff(1:n, train_idx)

train <- df_final[train_idx, ]
test <- df_final[test_idx, ]

# Target
y_train <- train$vital_status
y_test  <- test$vital_status

# Features avec model.matrix
X_train <- model.matrix(~ ., data = train[, setdiff(names(train), "vital_status")])[,-1]
X_test  <- model.matrix(~ ., data = test[, setdiff(names(test), "vital_status")])[,-1]

# Lasso avec CV sur le train
cv <- cv.glmnet(X_train, y_train, family = "binomial", alpha = 1)

# Meilleur lambda
lambda_best <- cv$lambda.min

# Entraîner modèle final
lasso <- glmnet(X_train, y_train, family = "binomial", alpha = 1, lambda = lambda_best)
```

```{r}
# Prédictions sur le test
yhat_test = predict(lasso, newx=X_test, type="response")
yhat_class <- ifelse(yhat_test > 0.08, "Dead", "Alive")
table(y_test, yhat_class)
# Taux de précision
mean(yhat_class == y_test)
```

```{r}
library(pROC)
roc_obj <- roc(y_test, yhat_test) 

# Afficher la courbe ROC
plot(roc_obj, col="blue", main="ROC Curve")

# Calculer AUC
auc(roc_obj)

# Trouver le seuil optimal selon le critère de Youden
opt <- coords(roc_obj, "best", best.method="youden", ret=c("threshold","sensitivity","specificity"))
print(opt)
```

# Model on both datasets penalizing GeneX only:

```{r}
df_complete <- cbind(Cdata, scale(Gdata))
df_complete[, num_cols] <- scale(df_complete[, num_cols] )
head(df_complete)
```


```{r}
# Variable cible
library(glmnet)
set.seed(0)

# Split 70% train / 30% test
n <- nrow(df_complete)
train_idx <- sample(1:n, size = 0.7*n)
test_idx <- setdiff(1:n, train_idx)

train <- df_complete[train_idx, ]
test <- df_complete[test_idx, ]

# Target
y_train <- train$vital_status
y_test  <- test$vital_status

# Features avec model.matrix
X_train <- model.matrix(~ ., data = train[, setdiff(names(train), "vital_status")])[,-1]
X_test  <- model.matrix(~ ., data = test[, setdiff(names(test), "vital_status")])[,-1]

# variables to penalize
pf <- rep(1, ncol(X_train))
pf[c(1:21)] <- 0

# Lasso avec CV sur le train
cv <- cv.glmnet(X_train, y_train, family = "binomial", alpha = 1, penalty.factor=pf)

# Meilleur lambda
lambda_best <- cv$lambda.min

# Entraîner modèle final
lasso <- glmnet(X_train, y_train, family = "binomial", alpha = 1, lambda = lambda_best, penalty.factor=pf)
```

```{r}
# Prédictions sur le test
yhat_test = predict(lasso, newx=X_test, type="response")
yhat_class <- ifelse(yhat_test > 0.24, "Dead", "Alive")
table(y_test, yhat_class)
# Taux de précision
mean(yhat_class == y_test)
```
```{r}
library(pROC)
roc_obj <- roc(y_test, yhat_test) 

# Afficher la courbe ROC
plot(roc_obj, col="blue", main="ROC Curve")

# Calculer AUC
auc(roc_obj)

# Trouver le seuil optimal selon le critère de Youden
opt <- coords(roc_obj, "best", best.method="youden", ret=c("threshold","sensitivity","specificity"))
print(opt)
```

```{r}
library(grpreg)

# Définir les groupes
# Ici variables 1 à 21 = groupe 1, le reste = groupe 2
group <- c(rep(1, 21), rep(2, ncol(X_train)-21))

# Cross-validation Group Lasso
lasso <- cv.grpreg(X_train, y_train, group = group, penalty = "grLasso", family = "binomial")

# Meilleur lambda
lambda_best <- cvfit$lambda.min
```
```{r}
# Prédictions sur le test
yhat_test = predict(lasso, X_test, lambda = lambda_best, type = "response")
yhat_class <- ifelse(yhat_test > 0.24, "Dead", "Alive")
table(y_test, yhat_class)
# Taux de précision
mean(yhat_class == y_test)
```

```{r}
library(pROC)
roc_obj <- roc(y_test, yhat_test) 

# Afficher la courbe ROC
plot(roc_obj, col="blue", main="ROC Curve")

# Calculer AUC
auc(roc_obj)

# Trouver le seuil optimal selon le critère de Youden
opt <- coords(roc_obj, "best", best.method="youden", ret=c("threshold","sensitivity","specificity"))
print(opt)
```
