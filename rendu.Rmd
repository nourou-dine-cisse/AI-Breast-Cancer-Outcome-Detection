---
title: "MRRPROJECT.Rmd"
output: html_document
date: "2025-11-24"
---

## Classification of Cancer outcome using Genetic and Clinical data

# Introduction

This project investigates the effect of genetic and clinical variables on the survival outcome of breast cancer patients. The data contains records of more than 1000 breast cancer patients from several research institutions. Clinical data contains patient-related and tumor-related information. Additionally mRNA gene expression data is available for each patient. The gene expression data has been processed to include only the top 5000 most variable genes on the transformed scale (log2(counts + 1)).

We consider that the main outcome variable of interest is **vital_status**, which is defined in clinical data.

## Data loading

```{r cars}
# Data loading
load("mrr_bio.Rdata")
library("S4Vectors")
```

```{r}
# genetic data
Gdata <- data.frame(GeneX)
```

```{r}
# clinical data
Cdata <- data.frame(clinical_data)

# Identiy the rows to keep
keep_idx <- !is.na(Cdata$vital_status)
# Filtrer Cdata
Cdata <- Cdata[keep_idx, ]
# Filtrer Gdata
Gdata <- Gdata[keep_idx, ]
```

```{r}
# The bcr_patient_barcode and primary_site can be dropped
Cdata$bcr_patient_barcode <- NULL # no relevant informations
# diesease type and primary_site column are constant so we will drop them
Cdata$disease_type <- NULL
Cdata$primary_site <- NULL
Cdata$days_to_birth <- NULL # redondent
Cdata$age_at_index <- NULL
Cdata$classification_of_tumor<-NULL
Cdata$diagnosis_is_primary_disease<-NULL
```

```{r}
Cdata_clean <- na.omit(Cdata)
merged_data <- merge(Cdata_clean, Gdata, by = 0)
dim(merged_data)
```

```{r}
rownames(merged_data)<-merged_data$Row.names
merged_data$Row.names<-NULL
Cdata <- Cdata_clean
Gdata <- merged_data[,colnames(Gdata)]
```

```{r}
# list variables dataframe
list_cols <- sapply(Cdata, is.list)
list_Cdata <- Cdata[, list_cols]
```

### Non-numerical variables encoding
Now there is no missing values we can procede to the encoding of non-numerical variables. Fortunatly R have a bultin function which is factor. It internally transform the categoriel variables into dummies.

```{r}
# we transfom the list variables into characters in order to be factorized
Cdata$sites_of_involvement <- sapply(Cdata$sites_of_involvement, function(x) paste(unlist(x), collapse = "_"))
Cdata$tissue_or_organ_of_origin <- sapply(Cdata$tissue_or_organ_of_origin, function(x) paste(unlist(x), collapse = "_"))
# Toutes les colonnes
all_cols <- colnames(Cdata)
num_cols <- sapply(Cdata, is.numeric)
num_Cdata <- Cdata[, num_cols]
# numerical columns
num_cols <- colnames(num_Cdata)

# non numerical columns
non_num_cols <- non_num_cols <- setdiff(colnames(Cdata), num_cols)

# Colonnes list
list_cols <- colnames(list_Cdata)

# transforming non numerical columns into factors
for (col in non_num_cols) {
  Cdata[[col]] <- as.factor(Cdata[[col]])
}
```

```{r}
sapply(Cdata, function(x) length(unique(x)))
```

# Model on clinical_data only:

```{r}
library(glmnet)
options(warn = 1)         # show warnings as they occur
set.seed(42)

# Split 70% train / 30% test
n <- nrow(Cdata)
Cdata_scaled <- Cdata
Cdata_scaled[, num_cols] <- scale(Cdata_scaled[, num_cols])
train_idx <- sample(1:n, size = 0.7 * n)
test_idx <- setdiff(1:n, train_idx)

train <- Cdata_scaled[train_idx, ]
test <- Cdata_scaled[test_idx, ]

# Target
y_train <- train$vital_status
y_test <- test$vital_status

# Features from model.matrix
X_train <- model.matrix(~., data = train[, setdiff(names(train), "vital_status")])[, -1]
X_test <- model.matrix(~., data = test[, setdiff(names(test), "vital_status")])[, -1]

# Lasso with CV on train data
cv <- cv.glmnet(X_train, y_train, family = "binomial", alpha = 1)

# best lambda
lambda_best <- cv$lambda.min

# trainfinal lasso model
#lasso <- glmnet(X_train, y_train, family = "binomial", alpha = 1, lambda = lambda_best)
```

```{r}
# Prediction on test dataset
yhat_test <- predict(cv,s=lambda_best, newx = X_test, type = "response")
yhat_class <- ifelse(yhat_test > 0.107, "Dead", "Alive")
table(y_test, yhat_class)
# Taux de précision
mean(yhat_class == y_test)
```
```{r}
library(pROC)
roc_obj <- roc(y_test, yhat_test)

# Plot ROC curve
plot(roc_obj, col = "blue", main = "ROC Curve")

# Best threshold according to Youden cryteria
opt <- coords(roc_obj, "best", best.method = "youden", ret = c("threshold", "sensitivity", "specificity"))
print(opt)
```

# Model on GeneX only:
```{r}
# Split 70% train / 30% test
set.seed(42)
Gdata_scaled <- data.frame(vital_status = Cdata$vital_status, scale(Gdata))

n <- nrow(Gdata_scaled)
train_idx <- sample(1:n, size = 0.7 * n)
test_idx <- setdiff(1:n, train_idx)

train <- Gdata_scaled[train_idx, ]
test <- Gdata_scaled[test_idx, ]

# Target
y_train <- train$vital_status
y_test <- test$vital_status

# Features from model.matrix
X_train <- model.matrix(~., data = train[, setdiff(names(train), "vital_status")])[, -1]
X_test <- model.matrix(~., data = test[, setdiff(names(test), "vital_status")])[, -1]

# Lasso with CV on train data
cv <- cv.glmnet(X_train, y_train, family = "binomial", alpha = 1)

# best lambda
lambda_best <- cv$lambda.min

# trainfinal lasso model
#lasso <- glmnet(X_train, y_train, family = "binomial", alpha = 1, lambda = lambda_best)
```

```{r}
# Prediction on test dataset
yhat_test <- predict(cv,s=lambda_best, newx = X_test, type = "response")
yhat_class <- ifelse(yhat_test > 0.107, "Dead", "Alive")
table(y_test, yhat_class)
# Taux de précision
mean(yhat_class == y_test)
```


```{r}
library(pROC)
roc_obj <- roc(y_test, yhat_test)

# Plot ROC curve
plot(roc_obj, col = "blue", main = "ROC Curve")

# Best threshold according to Youden cryteria
opt <- coords(roc_obj, "best", best.method = "youden", ret = c("threshold", "sensitivity", "specificity"))
print(opt)
```

# Screening Model:
```{r}
x <- scale(as.matrix(Gdata))
y <- Cdata$vital_status

cv <- cv.glmnet(x, y, family = "binomial", alpha = 1)

lasso <- glmnet(x, y, family = "binomial", alpha = 1, lambda = cv$lambda.min)

coef_lasso <- coef(lasso)

# Extraire les variables non nulles
sig_vars <- rownames(coef_lasso)[coef_lasso[, 1] != 0]
sig_vars <- sig_vars[sig_vars != "(Intercept)"]
```

```{r}
df_final <- cbind(Cdata, scale(Gdata[, sig_vars]))
df_final[, num_cols] <- scale(df_final[, num_cols])
head(df_final)
```

```{r}
library(glmnet)
set.seed(3)

# Split 70% train / 30% test
n <- nrow(df_final)
train_idx <- sample(1:n, size = 0.7 * n)
test_idx <- setdiff(1:n, train_idx)

train <- df_final[train_idx, ]
test <- df_final[test_idx, ]

# Target
y_train <- train$vital_status
y_test <- test$vital_status

# Features avec model.matrix
X_train <- model.matrix(~., data = train[, setdiff(names(train), "vital_status")])[, -1]
X_test <- model.matrix(~., data = test[, setdiff(names(test), "vital_status")])[, -1]

# Lasso avec CV sur le train
cv <- cv.glmnet(X_train, y_train, family = "binomial", alpha = 1)

# Meilleur lambda
lambda_best <- cv$lambda.min

# Entraîner modèle final
#lasso <- glmnet(X_train, y_train, family = "binomial", alpha = 1, lambda = lambda_best)
```

```{r}
# Prédictions sur le test
yhat_test <- predict(cv, s=lambda_best,newx = X_test, type = "response")
yhat_class <- ifelse(yhat_test > 0.08, "Dead", "Alive")
table(y_test, yhat_class)
# Taux de précision
mean(yhat_class == y_test)
```

```{r}
library(pROC)
roc_obj <- roc(y_test, yhat_test)

# Afficher la courbe ROC
plot(roc_obj, col = "blue", main = "ROC Curve")

# Calculer AUC
auc(roc_obj)

# Trouver le seuil optimal selon le critère de Youden
opt <- coords(roc_obj, "best", best.method = "youden", ret = c("threshold", "sensitivity", "specificity"))
print(opt)
```

# Model on both datasets penalizing GeneX only:

```{r}
df_complete <- cbind(Cdata, scale(Gdata))
df_complete[, num_cols] <- scale(df_complete[, num_cols])
head(df_complete)
```


```{r}
# Variable cible
library(glmnet)
set.seed(0)

# Split 70% train / 30% test
n <- nrow(df_complete)
train_idx <- sample(1:n, size = 0.7 * n)
test_idx <- setdiff(1:n, train_idx)

train <- df_complete[train_idx, ]
test <- df_complete[test_idx, ]

# Target
y_train <- train$vital_status
y_test <- test$vital_status

# Features avec model.matrix
X_train <- model.matrix(~., data = train[, setdiff(names(train), "vital_status")])[, -1]
X_test <- model.matrix(~., data = test[, setdiff(names(test), "vital_status")])[, -1]

# variables to penalize
pf <- rep(1, ncol(X_train))
pf[c(1:21)] <- 0

# Lasso avec CV sur le train
cv <- cv.glmnet(X_train, y_train, family = "binomial", alpha = 1, penalty.factor = pf)

# Meilleur lambda
lambda_best <- cv$lambda.min

# Entraîner modèle final
#lasso <- glmnet(X_train, y_train, family = "binomial", alpha = 1, lambda = lambda_best, penalty.factor = pf)
```

```{r}
# Prédictions sur le test
yhat_test <- predict(cv,s=lambda_best, newx = X_test, type = "response")
yhat_class <- ifelse(yhat_test > 0.24, "Dead", "Alive")
table(y_test, yhat_class)
# Taux de précision
mean(yhat_class == y_test)
```
```{r}
library(pROC)
roc_obj <- roc(y_test, yhat_test)

# Afficher la courbe ROC
plot(roc_obj, col = "blue", main = "ROC Curve")

# Calculer AUC
auc(roc_obj)

# Trouver le seuil optimal selon le critère de Youden
opt <- coords(roc_obj, "best", best.method = "youden", ret = c("threshold", "sensitivity", "specificity"))
print(opt)
```